#!/usr/bin/env bash

# Load plugin library
# shellcheck source=lib/plugin.bash
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/../lib/plugin.bash"

# Keep the existing settings
set -euo pipefail

check_required_env() {
  if [[ -z "${!1:-}" ]]; then
    log_error "Required environment variable $1 is not set"
    exit 1
  fi
}

add_ssh_host() {
  local host="$1"
  local fingerprint="$2"
  local tmp_file

  echo "home directory is $HOME"
  # Create .ssh directory if it doesn't exist
  echo "creating .ssh directory"

  if [ ! -d "$HOME/.ssh" ]; then
    echo "Creating .ssh directory..."
    mkdir -p "$HOME/.ssh"
    chmod 700 "$HOME/.ssh"
  else
      echo ".ssh directory already exists."
  fi

  # Create known_hosts file if it doesn't exist
  touch "$HOME/.ssh/known_hosts"

  # Check if host is already in known_hosts
  if ! grep -q "^$host" "$HOME/.ssh/known_hosts"; then
    log_info "$host not found in known_hosts"

    # Get host key
    log_info "Getting host key for $host"
    tmp_file=$(mktemp)
    if retry 5 ssh-keyscan -t rsa "$host" > "$tmp_file"; then
        log_success "Got host key for $host"
    else
        log_error "Failed to get host key for $host"
        exit 1
    fi

    # Verify fingerprint
    log_info "Verifying fingerprint for $host"
    local actual_fingerprint
    actual_fingerprint=$(ssh-keygen -lf "$tmp_file" | awk '{ print $2 }')

    if [[ "$actual_fingerprint" != "$fingerprint" ]]; then
      log_error "Fingerprint mismatch for $host. Expected $fingerprint, got $actual_fingerprint."
      rm "$tmp_file"
      exit 1
    fi

    # Add to known_hosts
    cat "$tmp_file" >> "$HOME/.ssh/known_hosts"
    rm "$tmp_file"
    log_info "$host added to known_hosts"
  fi
}

fetch_commit() {
  local clone_dir="$1"
  local fetch_target="$2"
  local fetch_flags=("${@:3}")

  pushd "$clone_dir" > /dev/null

  log_info "Fetching $fetch_target"
  [[ ${#fetch_flags[@]} -gt 0 ]] && log_info "Using flags: ${fetch_flags[*]}"

  git fetch origin "${fetch_flags[@]+"${fetch_flags[@]}"}" "$fetch_target" || return 1

  log_success "Fetch completed successfully"

  popd > /dev/null
}

clone_repository() {
  local repo_url="$1"
  local checkout_ref="$2"
  local ssh_key_path="$3"
  local clone_dir="$4"
  local mirror_url="${5:-}"
  local clone_flags=("${@:6}")

  log_info "Cloning repository into '$clone_dir'"
  mkdir -p "$clone_dir"
  pushd "$clone_dir" > /dev/null

  if [[ -n "$ssh_key_path" ]]; then
    export GIT_SSH_COMMAND="ssh -i $ssh_key_path -o IdentitiesOnly=yes"
  fi

  if [[ -n "$mirror_url" ]]; then
    log_info "Trying to clone from mirror: $mirror_url"
    if git clone "${clone_flags[@]}" "$mirror_url" .; then
      log_success "Cloned from mirror: $mirror_url"
      git remote set-url origin "$repo_url"
    else
      log_warning "Mirror clone failed, falling back to original URL: $repo_url"
      git clone "${clone_flags[@]}" "$repo_url" . || return 1
    fi
  else
    log_info "Clone flags: ${clone_flags[*]}"
    git clone "${clone_flags[@]}" "$repo_url" . || return 1
  fi

  popd > /dev/null

  log_info "Repository cloned successfully"
}

checkout_ref() {
  local clone_dir="$1"
  local checkout_ref="$2"

  pushd "$clone_dir" > /dev/null

  if [[ -n "$checkout_ref" ]]; then
    log_info "Checking out ref: $checkout_ref"
    git checkout "$checkout_ref" || return 1
  elif [[ -n "${BUILDKITE_COMMIT:-}" ]]; then
    log_info "Checking out commit: $BUILDKITE_COMMIT"
    git checkout "$BUILDKITE_COMMIT" || return 1
  fi

  if command -v git-lfs > /dev/null; then
    log_info "Setting up Git LFS"
    git lfs install || return 1
    git lfs pull || return 1
  fi

  popd > /dev/null

  log_success "Checkout completed successfully"
}

# Main execution
log_section ":open_file_folder: Setting up workspace"

# Check for skip checkout
if [[ "${BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_SKIP_CHECKOUT:-false}" == "true" ]]; then
  log_warning "üö´ Skipping default checkout as per configuration."

  # If we're just skipping checkout and no repos are specified, exit successfully
  if [[ -z "${BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_0:-}" && -z "${BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_0_URL:-}" ]]; then
    log_info "üìù No repositories configured for checkout, skipping repository checkout"
    exit 0
  fi
fi

# Ensure required environment variables are set
check_required_env "BUILDKITE_BUILD_CHECKOUT_PATH"
mkdir -p "$BUILDKITE_BUILD_CHECKOUT_PATH" || { log_error "Failed to create checkout path"; exit 1; }
cd "$BUILDKITE_BUILD_CHECKOUT_PATH" || { log_error "Failed to change to checkout path"; exit 1; }

log_section ":key: Configuring SSH"

# Add SSH hosts (configurable)
SSH_HOSTS=("github.com")
SSH_FINGERPRINTS=(
  "SHA256:uNiVztksCsDhcc0u9e8BujQXVUpKZIDTMczCvj3tD2s"
)

for i in "${!SSH_HOSTS[@]}"; do
  add_ssh_host "${SSH_HOSTS[$i]}" "${SSH_FINGERPRINTS[$i]}"
done

log_section ":git: Starting repository checkout"

# Repository checkout loop
REPOS_COUNT=0
CLONE_SUCCESS=false

while true; do
  REPO_URL_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_${REPOS_COUNT}_URL"
  REPO_MIRROR_URL_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_${REPOS_COUNT}_MIRROR_URL"

  if [[ -z "${!REPO_URL_VAR:-}" ]]; then
    REPO_URL_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_${REPOS_COUNT}"
    if [[ -z "${!REPO_URL_VAR:-}" ]]; then
      break
    fi
  fi

  REPO_URL="${!REPO_URL_VAR}"
  REPO_MIRROR_URL="${!REPO_MIRROR_URL_VAR:-}"
  log_info "Processing repository $REPOS_COUNT: $REPO_URL"

  REPO_REF_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_${REPOS_COUNT}_REF"
  REPO_SSH_KEY_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_${REPOS_COUNT}_SSH_KEY_PATH"
  REPO_CHECKOUT_PATH_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_${REPOS_COUNT}_CHECKOUT_PATH"
  REPO_FETCH_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_${REPOS_COUNT}_FETCH"

  CLONE_FLAGS_COUNT=0
  REPO_CLONE_FLAGS=()

  REPO_CLONE_FLAGS_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_${REPOS_COUNT}_CLONE_FLAGS_${CLONE_FLAGS_COUNT}"
  if [[ -z "${!REPO_CLONE_FLAGS_VAR:-}" ]]; then
    REPO_CLONE_FLAGS=("-v")
  fi

  while true; do
    REPO_CLONE_FLAGS_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_${REPOS_COUNT}_CLONE_FLAGS_${CLONE_FLAGS_COUNT}"
    if [[ -z "${!REPO_CLONE_FLAGS_VAR:-}" ]]; then
      break
    fi
    REPO_CLONE_FLAGS+=("${!REPO_CLONE_FLAGS_VAR}")
    ((CLONE_FLAGS_COUNT++))
  done

  FETCH_FLAGS_COUNT=0
  REPO_FETCH_FLAGS=()

  while true; do
    REPO_FETCH_FLAGS_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_${REPOS_COUNT}_FETCH_FLAGS_${FETCH_FLAGS_COUNT}"
    if [[ -z "${!REPO_FETCH_FLAGS_VAR:-}" ]]; then
      break
    fi
    REPO_FETCH_FLAGS+=("${!REPO_FETCH_FLAGS_VAR}")
    ((FETCH_FLAGS_COUNT++))
  done

  REPO_REF="${!REPO_REF_VAR:-}"
  REPO_SSH_KEY_PATH="${!REPO_SSH_KEY_VAR:-}"
  REPO_CHECKOUT_PATH="${!REPO_CHECKOUT_PATH_VAR:-}"
  REPO_FETCH="${!REPO_FETCH_VAR:-false}"

  # Determine the checkout directory for this repository
  if [[ -n "$REPO_CHECKOUT_PATH" ]]; then
    if [[ "$REPO_CHECKOUT_PATH" = /* ]]; then
      REPO_CLONE_DIR="$REPO_CHECKOUT_PATH"
    else
      REPO_CLONE_DIR="$BUILDKITE_BUILD_CHECKOUT_PATH/$REPO_CHECKOUT_PATH"
    fi
  else
    REPO_NAME=$(basename "$REPO_URL" .git)

    # Check if we have multiple repos
    NEXT_REPO_URL_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_$((REPOS_COUNT + 1))_URL"
    if [[ -z "${!NEXT_REPO_URL_VAR:-}" ]]; then
      NEXT_REPO_URL_VAR="BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_REPOS_$((REPOS_COUNT + 1))"
    fi

    if [[ $REPOS_COUNT -eq 0 && -z "${!NEXT_REPO_URL_VAR:-}" ]]; then
      # Single repository, clone to .
      REPO_CLONE_DIR="$BUILDKITE_BUILD_CHECKOUT_PATH"
    else
      # Multiple repositories, clone to ./repo
      REPO_CLONE_DIR="$BUILDKITE_BUILD_CHECKOUT_PATH/$REPO_NAME"
    fi
  fi

  if clone_repository "$REPO_URL" "$REPO_REF" "$REPO_SSH_KEY_PATH" "$REPO_CLONE_DIR" "$REPO_MIRROR_URL" "${REPO_CLONE_FLAGS[@]+"${REPO_CLONE_FLAGS[@]}"}"; then
    CLONE_SUCCESS=true
    log_success "Successfully cloned repository $REPO_URL"
  else
    log_error "Failed to clone repository $REPO_URL"
    exit 1
  fi

  if [[ "$REPO_FETCH" == "true" ]]; then
    FETCH_TARGET="${REPO_REF:-${BUILDKITE_COMMIT:-}}"
    if [[ -n "$FETCH_TARGET" ]]; then
      if ! fetch_commit "$REPO_CLONE_DIR" "$FETCH_TARGET" "${REPO_FETCH_FLAGS[@]+"${REPO_FETCH_FLAGS[@]}"}"; then
        log_error "Failed to fetch for repository $REPO_URL"
        exit 1
      fi
    else
      log_warning "Fetch enabled but no ref or commit specified, skipping fetch for $REPO_URL"
    fi
  fi

  if ! checkout_ref "$REPO_CLONE_DIR" "$REPO_REF"; then
    log_error "Failed to checkout ref for repository $REPO_URL"
    exit 1
  fi

  CLONE_SUCCESS=true
  log_success "Successfully processed repository $REPO_URL"

  ((REPOS_COUNT++))
done || true

if [[ $REPOS_COUNT -eq 0 ]]; then
  # Only error if we're not in skip_checkout mode
  if [[ "${BUILDKITE_PLUGIN_CUSTOM_CHECKOUT_SKIP_CHECKOUT:-false}" != "true" ]]; then
    log_error "No repositories configured for checkout"
    exit 1
  fi
  exit 0
fi

if [[ "$CLONE_SUCCESS" == "true" ]]; then
  log_info "All operations completed successfully"
  exit 0
else
  log_error "No repositories were successfully cloned"
  exit 1
fi
